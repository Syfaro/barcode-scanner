use std::num::NonZeroUsize;

use futures::{Future, Stream, StreamExt};
use ring_channel::{ring_channel, RingSender};
use tokio_util::sync::CancellationToken;

/// A worker for state.
///
/// Handles running async futures and streams, dispatching actions, and scoping
/// child actions.
pub struct StateWorker<A> {
    handle: tokio::runtime::Handle,
    tx: RingSender<A>,
    ctx: Option<eframe::egui::Context>,
    token: CancellationToken,
}

impl<A> StateWorker<A> {
    /// Create a new worker that transmits using the given sender.
    pub fn new(
        handle: tokio::runtime::Handle,
        tx: RingSender<A>,
        token: CancellationToken,
    ) -> Self {
        Self {
            handle,
            tx,
            token,
            ctx: None,
        }
    }

    /// Set the egui context for the worker. This causes the UI to update
    /// immediately after every action.
    pub fn set_egui_ctx(&mut self, ctx: eframe::egui::Context) -> &mut Self {
        self.ctx = Some(ctx);
        self
    }
}

impl<A> Drop for StateWorker<A> {
    fn drop(&mut self) {
        self.token.cancel();
    }
}

impl<A: Send + Sync + 'static> StateWorker<A> {
    /// Send the action to the worker.
    pub fn send(&self, action: A) {
        if let Err(err) = self.tx.send(action) {
            tracing::error!("could not send action: {err}");
        }
    }

    /// Perform an async operation that resolves to a single action.
    pub fn perform<F, Fut>(&self, fut: F) -> tokio::task::JoinHandle<()>
    where
        F: FnOnce() -> Fut + Send + Sync + 'static,
        Fut: Future<Output = A> + Send + Sync,
    {
        let tx = self.tx.clone();
        let ctx = self.ctx.clone();
        let token = self.token.clone();

        self.handle.spawn(async move {
            tokio::select! {
                _ = token.cancelled() => {
                    tracing::warn!("worker was cancelled while task was being performed");
                }
                action = fut() => {
                    Self::attempt_send(&ctx, &tx, action)
                }
            }
        })
    }

    /// Stream actions from a stream generated by a future.
    pub fn stream<F, Fut, Str>(&self, f: F) -> tokio::task::JoinHandle<()>
    where
        F: FnOnce() -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Str> + Send + Sync,
        Str: Stream<Item = A> + Send + Sync,
    {
        let tx = self.tx.clone();
        let ctx = self.ctx.clone();
        let token = self.token.clone();

        self.handle.spawn(async move {
            tokio::select! {
                _ = token.cancelled() => {
                    tracing::warn!("worker was cancelled while stream was initializing");
                }
                stream = f() => {
                    let mut stream = Box::pin(stream.take_until(token.cancelled()));

                    while let Some(action) = stream.next().await {
                        Self::attempt_send(&ctx, &tx, action)
                    }
                }
            }
        })
    }

    /// Handler for applying an action to the state.
    pub fn apply<S, F>(&self, state: &mut S, action: A, f: F)
    where
        F: FnOnce(&mut S, A),
    {
        f(state, action);

        if let Some(ctx) = &self.ctx {
            ctx.request_repaint();
        }
    }

    /// Scope a worker to a child, defining the method used to convert the
    /// child actions back to the parent.
    pub fn scoped<CA, F>(&self, f: F) -> StateWorker<CA>
    where
        CA: Send + 'static,
        F: Fn(CA) -> A + Send + 'static,
    {
        // Create a new channel for sending the data and create a task to
        // receive from it and map it to the correct types.
        let (tx, rx) = ring_channel::<CA>(NonZeroUsize::new(1).unwrap());

        let self_tx = self.tx.clone();
        let token = self.token.clone();

        self.handle.spawn(async move {
            let mut rx = Box::pin(rx.take_until(token.cancelled()));

            while let Some(child_action) = rx.next().await {
                let action = f(child_action);

                // We don't want to request repaints here because these actions
                // will be handled by a parent that will request it.
                Self::attempt_send(&None, &self_tx, action);
            }
        });

        StateWorker {
            handle: self.handle.clone(),
            tx,
            ctx: self.ctx.clone(),
            token: self.token.child_token(),
        }
    }

    /// Attempt to send an action to a channel, requesting a repaint after it
    /// was sent.
    fn attempt_send(ctx: &Option<eframe::egui::Context>, tx: &RingSender<A>, action: A) {
        match tx.send(action) {
            Ok(_) => {
                if let Some(ctx) = ctx {
                    tracing::trace!("sent action, requesting repaint");
                    ctx.request_repaint();
                }
            }
            Err(err) => tracing::error!("could not send result of task: {err}"),
        }
    }
}
