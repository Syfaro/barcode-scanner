use std::sync::Arc;

use futures::{Future, Stream, StreamExt};
use tokio::sync::mpsc::{unbounded_channel, UnboundedSender};
use tokio_util::sync::CancellationToken;
use tracing::Instrument;

/// A worker for state.
///
/// Handles running async futures and streams, dispatching actions, and scoping
/// child actions.
pub struct StateWorker<A> {
    pub inner: Arc<StateWorkerInner<A>>,
    ctx: Option<eframe::egui::Context>,
}

impl<A> Clone for StateWorker<A> {
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            ctx: self.ctx.clone(),
        }
    }
}

pub struct StateWorkerInner<A> {
    pub handle: tokio::runtime::Handle,
    tx: UnboundedSender<A>,
    token: CancellationToken,
}

impl<A> StateWorker<A> {
    /// Create a new worker that transmits using the given sender.
    pub fn new(
        handle: tokio::runtime::Handle,
        tx: UnboundedSender<A>,
        token: CancellationToken,
    ) -> Self {
        Self {
            inner: Arc::new(StateWorkerInner { handle, tx, token }),
            ctx: None,
        }
    }

    /// Set the egui context for the worker. This causes the UI to update
    /// immediately after every action.
    pub fn set_egui_ctx(&mut self, ctx: eframe::egui::Context) -> &mut Self {
        self.ctx = Some(ctx);
        self
    }
}

impl<A> Drop for StateWorkerInner<A> {
    fn drop(&mut self) {
        self.token.cancel();
    }
}

impl<A: Send + 'static> StateWorker<A> {
    /// Send the action to the worker.
    pub fn send(&self, action: A) {
        Self::attempt_send(&self.ctx, &self.inner.tx, action)
    }

    /// Perform an async operation that resolves to a single action.
    pub fn perform<Fut>(&self, fut: Fut) -> tokio::task::JoinHandle<()>
    where
        Fut: Future<Output = A> + Send + 'static,
    {
        let inner = self.inner.clone();
        let ctx = self.ctx.clone();

        self.inner.handle.spawn(
            async move {
                tokio::select! {
                    _ = inner.token.cancelled() => {
                        tracing::warn!("worker was cancelled while task was being performed");
                    }
                    action = fut => {
                        Self::attempt_send(&ctx, &inner.tx, action)
                    }
                }
            }
            .in_current_span(),
        )
    }

    /// Stream actions from a stream generated by a future.
    pub fn stream<Fut, Str>(&self, fut: Fut) -> tokio::task::JoinHandle<()>
    where
        Fut: Future<Output = Str> + Send + 'static,
        Str: Stream<Item = A> + Send,
    {
        let inner = self.inner.clone();
        let ctx = self.ctx.clone();

        self.inner.handle.spawn(
            async move {
                tokio::select! {
                    _ = inner.token.cancelled() => {
                        tracing::warn!("worker was cancelled while stream was initializing");
                    }
                    stream = fut => {
                        let mut stream = Box::pin(stream.take_until(inner.token.cancelled()));

                        while let Some(action) = stream.next().await {
                            Self::attempt_send(&ctx, &inner.tx, action)
                        }
                    }
                }
            }
            .in_current_span(),
        )
    }

    /// Handler for applying an action to the state.
    pub fn apply<S, F>(&self, state: &mut S, action: A, f: F)
    where
        F: FnOnce(&mut S, A),
    {
        f(state, action);
    }

    /// Scope a worker to a child, defining the method used to convert the
    /// child actions back to the parent.
    pub fn scoped<CA, F>(&self, f: F) -> StateWorker<CA>
    where
        CA: Send + 'static,
        F: Fn(CA) -> A + Send + 'static,
    {
        // Create a new channel for sending the data and create a task to
        // receive from it and map it to the correct types.
        let (tx, rx) = unbounded_channel::<CA>();

        let inner = self.inner.clone();

        self.inner.handle.spawn(
            async move {
                let stream = tokio_stream::wrappers::UnboundedReceiverStream::new(rx);
                let mut rx = Box::pin(stream.take_until(inner.token.cancelled()));

                while let Some(child_action) = rx.next().await {
                    let action = f(child_action);

                    // We don't want to request repaints here because these actions
                    // will be handled by a parent that will request it.
                    Self::attempt_send(&None, &inner.tx, action);
                }
            }
            .in_current_span(),
        );

        StateWorker {
            inner: Arc::new(StateWorkerInner {
                handle: self.inner.handle.clone(),
                tx,
                token: self.inner.token.child_token(),
            }),
            ctx: self.ctx.clone(),
        }
    }

    /// Attempt to send an action to a channel, requesting a repaint after it
    /// was sent.
    fn attempt_send(ctx: &Option<eframe::egui::Context>, tx: &UnboundedSender<A>, action: A) {
        match tx.send(action) {
            Ok(_) => {
                if let Some(ctx) = ctx {
                    tracing::trace!("sent action, requesting repaint");
                    ctx.request_repaint();
                }
            }
            Err(err) => tracing::error!("could not send result of task: {err}"),
        }
    }
}
